CUBO ARCHITECTURE V3 (Multi-Stage, Optimizing JIT)
CUBO is an advanced Just-In-Time (JIT) compiler designed for a subset of the C programming language. This version of CUBO incorporates a multi-stage compilation process, including an optional optimization phase, to translate source code into executable machine code.
Architecture Overview
The compilation process in CUBO follows a well-defined sequence of stages:
 * Lexer: The initial stage scans the source code and transforms it into a stream of Tokens. These tokens represent the fundamental building blocks of the program, such as keywords, identifiers, literals, and operators.
 * Parser: This stage consumes the tokens generated by the Lexer and constructs an Abstract Syntax Tree (AST). The AST is a hierarchical representation of the program's structure, illustrating the relationships between different language constructs (e.g., an assignment statement with its variable and expression).
 * Optimizer: This is an optional stage that operates on the AST. If enabled (via the -c1 flag), it performs simplifications to improve the efficiency of the code. A key optimization implemented is Constant Folding, where constant expressions (like 5 + 10) are evaluated at compile time and replaced with their results (e.g., 15).
 * Bytecode Emitter: This stage traverses the (potentially optimized) AST and generates a simple, linear, stack-based Intermediate Representation (IR), referred to as bytecode. This bytecode is a low-level, platform-independent representation of the program's logic.
 * JIT Backend: The core of the JIT compilation process. This component translates the bytecode into native x86_64 Machine Code. It handles register allocation, stack management, and the generation of specific machine instructions.
 * Execution: The final stage where the generated machine code, residing in an executable memory buffer, is executed. The result of the program (its return value) is then captured.
Building CUBO
To compile the CUBO compiler, use a C compiler such as clang with the following command:
clang -O2 -o cubo cubo.c

This command will create an executable file named cubo.
Running CUBO
Once compiled, you can run CUBO to compile and execute your C subset source files. The compiler supports different optimization levels:
 * No Optimizations: To compile and run your code without any optimizations, use the -c0 flag:
   ./cubo -c0 your_file.c

 * With Constant Folding Optimization: To enable the constant folding optimization, use the -c1 flag:
   ./cubo -c1 your_file.c

After execution, the program's return value will be available as the shell's exit code. You can inspect it using:
echo $?

Example Usage
Given a C subset source file example.c:
int main() {
    int x = 5 + 10;
    if (x == 15) {
        return 42;
    } else {
        return 0;
    }
}

To compile and run with constant folding:
./cubo -c1 example.c
echo $?
# Expected output: 42

To compile and run without constant folding:
./cubo -c0 example.c
echo $?
# Expected output: 42

